1.面试
  非技术面试 ：：HR（人事）
  技术面试：公司Leader（项目组长，项目经理，项目总监）
2.没有准备的面试就是侮辱面试官
3.明天就是面试
-------------------------------------------------------------
4.技术面试的细节：
      4.1 基础技能（非项目）：技术技能（零散的）
      4.2 项目经验：3年保底
      4.3 毕业薪资：10k
-------------------------------------------------------------
5.手机上安装面试题软件 ，找工作的App
  应用市场搜索：
  Java面试
  设计模式
  框架相关的

App：BOSS直聘
     拉钩
     猎聘
在线简历
附件简历
----------------------------------------------------------------
6.面试是双向选择：
    多线程：遇到刚才的场景，您会怎么处理？？
7.
  封装:将数据和过程（行为：方法）包装起来，只保留一个对外访问的接口，起到了保护数据的作用。
封装的两种体现
    类：字段+方法
    私有字段封装成公有方法
  继承：extends
    子类继承父类的所有     非私有的并且   是实例方法和变量，达到的效果是对父类功能进行增强，并且可以复用父类的一些行为
    或者数据，基于这些功能又高于父类的功能。

  父类：基类 超类
  子类：派生类 PDF电子书

  多态：不同的对象  对于 同一个行为  表现方式不同
       橡皮鸭子：A叫法
       木头鸭子：B叫法
       真实鸭子：嘎嘎


      多个国家的打招呼，说你好
      chinese：您好
      korea: XXXXX
      American：Hello

     应用层面：动态绑定：
     public class BaseFactory{
        public Base getInstance(String oper){
              Base base=null;
              switch(oper){
                 case "A":
                   base=new ChildA();
                 break;
              }
              return base;
        }
     }
    多态的终极目标： 【统一调用】
    一个父类，三个子类
    做法：定义父类型的集合，将子类对象方法父类集合
    遍历父类集合的时候，直接item.sayHello();

   抽象：
   public abstract String calcMd5(String str);
   public void test(){
     巴拉巴拉实现
   }

Comparable<Integer>接口中有一个compareTo方法，返回int
   <0 小于
   =0 相等
   >0 大于

作业：
      1.用code去模拟堆和栈
      2.原码，反码，补码


2019年5月7日
1.JVM内存模型
2.类加载器
3.内部类


-----------------------------
1.研发反馈系统
  测试用一下
2.面试大家
  1.做一个自我介绍
    100分：50分
    1.1 个人简历  没有 把自己的技能说出来（专业技能）
    1.2 准备不足
    1.3 临场发挥能力，声音洪亮，吐字清晰
    1.4 组织介绍用语的先后次序
  2.MVC框架：
  3.数据库：
    Mysql版本
  4.Ajax
  5.多线程
  6.JVM
  7.Springboot
  8.JDK新特性
  9.JDK源码
3.软件公司的组织结构  50---100
  研发部：
  销售部：最挣钱的
  人事部：
  财务部：（财务）/出纳（出入）
  测试部：黑盒测试和白盒测试
  运维部：项目集群问题，或者是网络问题
  实施部：上门安装软件，讲解培训
  中间件研发部：



  牛X的人：技术总监、项目经理（管理岗位） 1
          架构师（技术）
  老油条：工作了2年以上（项目组长） 每组一个  多个项目组
  开发：层次相当： 程序员（软件工程师） 开发的，
         3-4开发

  前端：1个   html，css,js
  UI ：1个  切图 ，视觉工程师
  测试：1个


4.公司中的一天
  上午：   1.查收邮件
          2.周一  和 周五 周例会
          3.公司代码服务器，版本控制服务器(git/svn)等。
            从git上checkout代码（第一次）
            从git同步别人的代码（同步别人代码）
            廖雪峰：git专题
          4.开发自己的模块  （人对接）
          5.


  下午：
       下午：单元测试程序员做的。功能性测试，性能测试（对接其他岗位人员）
                 下班前新的版本。git
              git add  添加到暂存区
              git commit   从暂存区 踢人到 本地仓库
              git push    从本地仓库提交到git服务器

  晚上：调Bug，或者是有人习惯好的
        任务的文档
        定制明天的研发任务

3.饼图---------讲解一下
4.面试题录制视频任务



dll:
dynamic linked library
动态链接库


  public synchronized void start() {
        /**
         * This method is not invoked for the main method thread or "system"
         * group threads created/set up by the VM. Any new functionality added
         * to this method in the future may have to also be added to the VM.
         *
         * A zero status value corresponds to state "NEW".
         */
        if (threadStatus != 0)
            throw new IllegalThreadStateException();

        /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
        group.add(this);

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {
            try {
                if (!started) {
                    group.threadStartFailed(this);
                }
            } catch (Throwable ignore) {
                /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
            }
        }
    }


	---------------------------------
	 private native void start0();


	 native是调度本地c++代码


	 JDK
	 JRE

我们本来是想看Object的hashCode，翻看源码后发现，Ojbect的hashCode是本地方法，
所有我们看了String的hashcode方法，原型如下：

 public int hashCode() {
        int h = hash;
        if (h == 0 && value.length > 0) {
            char val[] = value;

            for (int i = 0; i < value.length; i++) {
                h = 31 * h + val[i];
            }
            hash = h;
        }
        return h;
    }

-------------------------------------------------------------------
1.Java虚拟机
  JVM
  JDK
  JRE

     JVM是JRE的一部分
     JVM可以帮我们做内存管理

     我们可以这样理解：当数据被放入JVM的时候，数据会被分解到不同的位置。

  JVM运行时数据区
     一个类加载到JVM中被分解到什么位置？？？
     程序计数器：指向当前线程正在执行的字节码指令的地址和行号
         https://blog.csdn.net/leaf_0303/article/details/78953669
         https://www.cnblogs.com/thiaoqueen/p/8455521.html
         CPU运行指令是抢占式的
     虚拟机栈：存储当前线程运行方法所需要的数据，指令和返回地址
          方法是由线程执行的

      线程只是一个运行单位：
      https://www.cnblogs.com/minisculestep/articles/4934947.html
     方法区

     http://blog.sina.com.cn/s/blog_b880bf2d0102vwa1.html
     https://www.cnblogs.com/zuoxiaolong/p/jvm5.html
     https://www.cnblogs.com/lewis0077/p/5143268.html
     https://www.jianshu.com/p/76959115d486
     https://www.cnblogs.com/jiyukai/p/6665199.html
     https://blog.csdn.net/leaf_0303/article/details/78953669

  JVM内存模型
不错哇
https://www.cnblogs.com/yulinfeng/p/5883668.html

2019年5月9日08:31:37
1.JVM
  JDK
  JRE
2.运行时数据区 ------>Java内存结构
                     Java内存模型

  ----指令区  线程独享   线程安全的 。每个线程各持有一份
  1。线程计数器  ------》记录地址（PDF，下一个指令的地址）
  2.虚拟机栈 ----------》N个栈帧
      栈帧 FILO First In  Last Out
          1。成员变量表   int num=1; int num2=2;
          2。操作数栈    int num3=num+num2;
          3. 动态链接
          4.返回结果
  3.本地方法栈

  -----数据区
       方法区
       堆
 方法区：
   对于JVM的方法区，可能听得最多的是另外一个说法——永久代（Permanent Generation），
   呼应堆的新生代和老年代。方法区和堆的划分是JVM规范的定义，而不同虚拟机有不同实现，
   对于Hotspot虚拟机来说，将方法区纳入GC管理范围，这样就不必单独管理方法区的内存，所以就有了”永久代“这么一说。
   方法区和操作系统进程的正文段（Text Segment）的作用非常类似，它存储的是已被虚拟机加载的类信息、常量
   （从JDK7开始已经移至堆内存中）、静态变量等数据。现设置JVM参数为”-XX:MaxPermSize=20M”（方法区最大内存为20M）
   。

   方法区：类信息 Student.class  静态变量，常量，JIT中间代码

  堆：对于堆（整个JVM中占用空间最大一块区域），Java程序员都知道对象实例以及数组内存都要在堆上分配。
      堆不再被线程所独有而是共享的一块区域，它的确是用来存放对象实例，也是垃圾回收GC的主要区域。
      实际上它还能细分为：新生代（Young Generation）、老年代（Old Generation）。
      对于新生代又分为Eden空间、From Survivor空间、To Survivor空间。至于为什么这么分，
      这涉及JVM的垃圾回收机制，在这里不做叙述。堆同样会抛出OOM异常，下面例子设置JVM参数”
      -Xms20M -Xmx20M“（前者表示初始堆大小20M，后者表示最大堆大小20M）。

-----------------------------------Java内存模型-JMM(Java Memory Model)----------------------------------------
JMM是Java虚拟机的规范：
用来指导Java内存结构如何去处理或者存放数据
主内存(thread share)和工作内存(thread private)：

　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出
变量这样的底层细节。
    此处的变量与Java编程里面的变量有所不同，它包含了实例字段、静态字段和构成数组对象的元素，
但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，当然不存在数据竞争问题（如果局部变量
是一个reference引用类型，它引用的对象在Java堆中可被各个线程共享，但是reference引用本身在Java栈
的局部变量表中，是线程私有的）。为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器
的特定寄存器或者缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

    JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存（Working Memory）,
线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）
都必须在工作内存中进行，而不能直接读写主内存中的变量（volatile变量仍然有工作内存的拷贝，
但是由于它特殊的操作顺序性规定，所以看起来如同直接在主内存中读写访问一般）。
不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。


http://youzhixueyuan.com/jvm-garbage-collection-algorithm.html

https://blog.csdn.net/qq_34337272/article/details/82177383


内部类
https://blog.csdn.net/weixin_39214481/article/details/80372676



















