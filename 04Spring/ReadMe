2019年4月10日 Spring
1.Spring第一个入门案例
  四个步骤：
2.普通属性和域属性的注入
  域属性:如果在一个类中，有一个属性的类型又是一个复杂类型，这个时候我们称该属性为域属性

  public  class Person{
    private String name;
    private Integer age;
    //域属性
    private Car car;
  }
  public class Car{
      private String brand;
      private String color;
  }
3.复杂的打印机案例实现IOC
打印机分类
三种：
 喷墨打印机  墨盒 （黑色 ，彩色墨盒）
 针式打印机  三联单  24K
 激光打印机  面板智能按键 功能很全

Paper ----interface
   A4Paper
   B5Paper
Ink    ----Interface
   GrayInk
   ColorInk
Printer class
   Ink
   Paper
  print(){
  }
 2019年4月11日
 复习：
 1.图形
 2.IOC  Inverse Of Control 控制反转
    我们之前创建对象的时候，都是硬编码，直接在code体现，一个接口的实现类是谁，或者一个类型的具体对象。
    在有了SPring技术后，我们可以借助SPring这个容器，容器其实上底层就是一个大Map来管理我们的多个对象。
    对象的创建不再需要我们手工new了。我们程序员就可以从负责的构建对象的业务中解放出来，直接提供我们
    需要创建对象的类型就OK了。

    喜乐街：沙溢   贾玲   白凯南
    new：程序创建对象
    spring容器，需要简单的配置或者注解（容器扫描一个指定目录，帮我们将类型的对象构建出来）

    反转：对象的生成权从代码层面      反 转给了     Spring容器。

    HelloService  service;
    sout(service);

    <bean id="service" class="cn.happy.day02.HelloService">
        <property name="xxx" value="yyy"></property>
        <property name="xxx" ref="另一个bean节点的id"></property>
    </bean>

    测试类：
    说白了就是Spring容器
    ApplicationContext  ctx=new ClassPathXmlApplicationContext("applicationContext.xml");

    ctx.getBean("bean的id",HelloService.class);


 编译时：
   检查异常  语法错误
   class文件：：：：：：：：：：：：：：：

 运行时
   运行时异常
   IOC




 1.AOP 思想
    7个专业术语
 2.DI和IOC
 3.讲解DI操作
       三种方式：
       set方法注入
       构造注入
       p注入方式
 4.自动注入



2019年4月12日08:36:38
1.回顾昨天内容
  AOP案例：
  Aspect  Oriented Programming  面向切面编程
  金牌结论：AOP最终达到的目标对类中方法做增强。
  程序运行时动态组合原来的方法体和增强。

  AOP只是实现增强一种手段，AOP 过滤器（编码，和鉴权）。

2.如何我想只增强类中的部分方法：
方案一：云飞版：增删改返回结果都约定成int，这个时候通过returnValue进行限定。
方案二：约定优于配置 需要事务的方法，都加上一个tx前缀
方案三：在PointCut动手脚 ，枚举出来所有增删改打头的三类方法。


  增强：
  前置增强  MethodBeforeAdvice
  后置增强  AfterReturningAdvice



  集合属性注入
2.切点表达式
3.AOP专业术语
4.基于注解的DI

5.代理：静态代理
        动态代理：JDK  CGLIB
6.AOP  代理工厂Bean


2019年4月15日08:34:02
1.关联关系
  1.一对一
  2.一对多
    配置：单条SQL  多表连接查询
         多条SQL
     collection

  3.多对一
        配置：单条SQL  多表连接查询
             多条SQL
        assocation
  4.多对多
           配置：单条SQL
           两表的多对多，我们一般思路将其转换成  两个一对多
           中间表的植入
           select * from studen,student_teacher,teacher
           where student.studentno=student_teacher.studentno
           and student_teacher.tid=teacher.tid
           and teacher.tid=#{tid}
           collection
  5.自关联
    特殊应用场景：
    无限极菜单设计
    Table设计
    Category表
    cid  cname      pid
     1    图书        0
     2    服装        0
     3    青年图书    1

     2条SQL   2条SQL   2条SQL

     1条SQL

     3条SQL


 多条SQL配置
 第一条SQL
和第二条SQL
2.延迟加载：就是等真正使用关联对象属性的时候再去加载，
分三种：默认情况下使用的是【直接加载】  实现延迟，我们得 手工【配置】
    直接加载
    侵入式延迟  lazyLoad=true          arrasiveLoading=true
      使用主对象的属性 ，子对象的SQL发送了
    深度延迟

       lazyLoad=true          arrasiveLoading=false
       使用关联对象的属性的时候，才加载
 3.缓存：加快检索速度
   分成：
   一级缓存：同一个SqlSession中
   sqlid 选择不用一级缓存吗？自带的



   二级缓存：同一个 SQLSessionFactory
            同一个 mapper/namespace


   二级缓存默认：开启的
   开启和能使用时两回事

   开启二级缓存：
   1.在config配置中 设置 cacheEnabled =true
   2.mapper文件中，<cache eviction="缓存对象的清理策略FIFO/LRU(默认的)" flushInterval="刷新频率 60000"  size="1024"/>
   3.缓存的对象一定要实现一个接口  Serializable

   配置第三方缓存插件

   EhCache：
         引入依赖
         <cache type>
         ehcache.xml

Spring回顾
3.IOC
  IOC：控制反转：对象的创建
           以前对象都是new出来的， 配置文件--------> Spring容器
           code层面：
           ApplicationContext：

           new ClassXmlPathApplicationContext


           ctx.getBean("beanid",HelloService.class);

  DI：依赖注入
      三种注入方式：set方法注入
          <property name="age" value="18">
          <property name="car" ref="car">

                  构造注入
           <constructor-arg index="0" value="xxxx"></constructor-arg>
            <constructor-arg index="1" ref="域属性"></constructor-arg>
                  p命名空间注入
                 <bean p:name="xxx"  p:car-ref="car">
4.AOP
     AOP 对方法功能进行增强的
         前置
         （MethodBeforeAdvice）和后置增强（AfterReturningAdvice）
     U2：过滤器
        MyBeforeAdvice {

        }
     配置文件：

     <aop:config>
        切点
        <aop:pointcut id="mypoint" expression="execution(* *..service.impl.UserServiceImpl.*(..))">
        织入
        <aop:advisor pointcut-ref="mypoint" advice-ref="beforeAdvice">
     </aop:config>

5.基于注解DI
Spring注解
@Component  类被Spring管理的bean
@Repository  dao层
@Service     service层
@Controller  controller

属性：
普通属性赋值
@value

域属性赋值
@Resource(name="xxx")  JDK的

@Autowired   Spring注解
@Qualifire

6.代理分类
静态代理
    代理模式
    接口   真正实现类   代理实现类 植入真实实现类的对象

    客户端使用的时候，用的是代理对象的方法，对客户来说，变相的对真实对象的方法进行了增强。
    他的思想是在硬盘上创建代理类

单例：
public class StudentSingleton{
   public static StudentSingleton onlyOne=new StudentSingleton();
   private StudentSingleton(){
   }
   public StudentSingleton getInstance(){
      if(onlyOne==null){
        onlyOne=new StudentSingleton(); //懒汉模式
      }
   }
}


动态代理
  JDK动态代理
  Class clazz=对象名.getClass();
  clazz.getClassLoader();
   public static Object newProxyInstance
   (ClassLoader loader,  类加载器
    Class<?>[] interfaces, clazz.getInterfaces() 所有接口集合
   InvocationHandler h)   Invoke调用
   Invocation 调用
   Handler：处理


final  IHelloService helloService=new HelloSericeImpl();
IHelloService proxy=(IHelloService)Proxy.newProxyInsatance(ClassLoader,Interfaces,new InvocationHandler(){
   public Object invoke(Object obj,Method method,Object... args){
       sout("log");
       Object result=method.invoke(helloService,args);
       return result;
   }

});
proxy.doSome();





复习计划














