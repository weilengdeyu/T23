2019年4月10日 Spring
1.Spring第一个入门案例
  四个步骤：
2.普通属性和域属性的注入
  域属性:如果在一个类中，有一个属性的类型又是一个复杂类型，这个时候我们称该属性为域属性

  public  class Person{
    private String name;
    private Integer age;
    //域属性
    private Car car;
  }
  public class Car{
      private String brand;
      private String color;
  }
3.复杂的打印机案例实现IOC
打印机分类
三种：
 喷墨打印机  墨盒 （黑色 ，彩色墨盒）
 针式打印机  三联单  24K
 激光打印机  面板智能按键 功能很全

Paper ----interface
   A4Paper
   B5Paper
Ink    ----Interface
   GrayInk
   ColorInk
Printer class
   Ink
   Paper
  print(){
  }
 2019年4月11日
 复习：
 1.图形
 2.IOC  Inverse Of Control 控制反转
    我们之前创建对象的时候，都是硬编码，直接在code体现，一个接口的实现类是谁，或者一个类型的具体对象。
    在有了SPring技术后，我们可以借助SPring这个容器，容器其实上底层就是一个大Map来管理我们的多个对象。
    对象的创建不再需要我们手工new了。我们程序员就可以从负责的构建对象的业务中解放出来，直接提供我们
    需要创建对象的类型就OK了。

    喜乐街：沙溢   贾玲   白凯南
    new：程序创建对象
    spring容器，需要简单的配置或者注解（容器扫描一个指定目录，帮我们将类型的对象构建出来）

    反转：对象的生成权从代码层面      反 转给了     Spring容器。

    HelloService  service;
    sout(service);

    <bean id="service" class="cn.happy.day02.HelloService">
        <property name="xxx" value="yyy"></property>
        <property name="xxx" ref="另一个bean节点的id"></property>
    </bean>

    测试类：
    说白了就是Spring容器
    ApplicationContext  ctx=new ClassPathXmlApplicationContext("applicationContext.xml");

    ctx.getBean("bean的id",HelloService.class);


 编译时：
   检查异常  语法错误
   class文件：：：：：：：：：：：：：：：

 运行时
   运行时异常
   IOC




 1.AOP 思想
    7个专业术语
 2.DI和IOC
 3.讲解DI操作
       三种方式：
       set方法注入
       构造注入
       p注入方式
 4.自动注入



2019年4月12日08:36:38
1.回顾昨天内容
  AOP案例：
  Aspect  Oriented Programming  面向切面编程
  金牌结论：AOP最终达到的目标对类中方法做增强。
  程序运行时动态组合原来的方法体和增强。

  AOP只是实现增强一种手段，AOP 过滤器（编码，和鉴权）。

2.如何我想只增强类中的部分方法：
方案一：云飞版：增删改返回结果都约定成int，这个时候通过returnValue进行限定。
方案二：约定优于配置 需要事务的方法，都加上一个tx前缀
方案三：在PointCut动手脚 ，枚举出来所有增删改打头的三类方法。


  增强：
  前置增强  MethodBeforeAdvice
  后置增强  AfterReturningAdvice



  集合属性注入
2.切点表达式
3.AOP专业术语
4.基于注解的DI

5.代理：静态代理
        动态代理：JDK  CGLIB
6.AOP  代理工厂Bean


2019年4月15日08:34:02
1.关联关系
  1.一对一
  2.一对多
    配置：单条SQL  多表连接查询
         多条SQL
     collection

  3.多对一
        配置：单条SQL  多表连接查询
             多条SQL
        assocation
  4.多对多
           配置：单条SQL
           两表的多对多，我们一般思路将其转换成  两个一对多
           中间表的植入
           select * from studen,student_teacher,teacher
           where student.studentno=student_teacher.studentno
           and student_teacher.tid=teacher.tid
           and teacher.tid=#{tid}
           collection
  5.自关联
    特殊应用场景：
    无限极菜单设计
    Table设计
    Category表
    cid  cname      pid
     1    图书        0
     2    服装        0
     3    青年图书    1

     2条SQL   2条SQL   2条SQL

     1条SQL

     3条SQL


 多条SQL配置
 第一条SQL
和第二条SQL
2.延迟加载：就是等真正使用关联对象属性的时候再去加载，
分三种：默认情况下使用的是【直接加载】  实现延迟，我们得 手工【配置】
    直接加载
    侵入式延迟  lazyLoad=true          arrasiveLoading=true
      使用主对象的属性 ，子对象的SQL发送了
    深度延迟

       lazyLoad=true          arrasiveLoading=false
       使用关联对象的属性的时候，才加载
 3.缓存：加快检索速度
   分成：
   一级缓存：同一个SqlSession中
   sqlid 选择不用一级缓存吗？自带的



   二级缓存：同一个 SQLSessionFactory
            同一个 mapper/namespace


   二级缓存默认：开启的
   开启和能使用时两回事

   开启二级缓存：
   1.在config配置中 设置 cacheEnabled =true
   2.mapper文件中，<cache eviction="缓存对象的清理策略FIFO/LRU(默认的)" flushInterval="刷新频率 60000"  size="1024"/>
   3.缓存的对象一定要实现一个接口  Serializable

   配置第三方缓存插件

   EhCache：
         引入依赖
         <cache type>
         ehcache.xml

Spring回顾
3.IOC
  IOC：控制反转：对象的创建
           以前对象都是new出来的， 配置文件--------> Spring容器
           code层面：
           ApplicationContext：

           new ClassXmlPathApplicationContext


           ctx.getBean("beanid",HelloService.class);

  DI：依赖注入
      三种注入方式：set方法注入
          <property name="age" value="18">
          <property name="car" ref="car">

                  构造注入
           <constructor-arg index="0" value="xxxx"></constructor-arg>
            <constructor-arg index="1" ref="域属性"></constructor-arg>
                  p命名空间注入
                 <bean p:name="xxx"  p:car-ref="car">
4.AOP
     AOP 对方法功能进行增强的
         前置
         （MethodBeforeAdvice）和后置增强（AfterReturningAdvice）
     U2：过滤器
        MyBeforeAdvice {

        }
     配置文件：

     <aop:config>
        切点
        <aop:pointcut id="mypoint" expression="execution(* *..service.impl.UserServiceImpl.*(..))">
        织入
        <aop:advisor pointcut-ref="mypoint" advice-ref="beforeAdvice">
     </aop:config>

5.基于注解DI
Spring注解
@Component  类被Spring管理的bean
@Repository  dao层
@Service     service层
@Controller  controller

属性：
普通属性赋值
@value

域属性赋值
@Resource(name="xxx")  JDK的

@Autowired   Spring注解
@Qualifire

6.代理分类
静态代理
    代理模式
    接口   真正实现类   代理实现类 植入真实实现类的对象

    客户端使用的时候，用的是代理对象的方法，对客户来说，变相的对真实对象的方法进行了增强。
    他的思想是在硬盘上创建代理类

单例：
public class StudentSingleton{
   public static StudentSingleton onlyOne=new StudentSingleton();
   private StudentSingleton(){
   }
   public StudentSingleton getInstance(){
      if(onlyOne==null){
        onlyOne=new StudentSingleton(); //懒汉模式
      }
   }
}


动态代理
  JDK动态代理
  Class clazz=对象名.getClass();
  clazz.getClassLoader();
   public static Object newProxyInstance
   (ClassLoader loader,  类加载器
    Class<?>[] interfaces, clazz.getInterfaces() 所有接口集合
   InvocationHandler h)   Invoke调用
   Invocation 调用
   Handler：处理


final  IHelloService helloService=new HelloSericeImpl();
IHelloService proxy=(IHelloService)Proxy.newProxyInsatance(ClassLoader,Interfaces,new InvocationHandler(){
   public Object invoke(Object obj,Method method,Object... args){
       sout("log");
       Object result=method.invoke(helloService,args);
       return result;
   }

});
proxy.doSome();
2019年4月16日
Advice：通知
1.顾问  Advisor
NameMatchMethodPointcutAdvisor
  ----
RegexpMethodPointcutAdvisor
Advisor：顾问
顾问：包装通知的。

1.1再问正则？
正则是什么？
一个字符串，长相比较奇怪  yymqqc@126.com   \w+@\w+\.\w+

正则作用 ？？
匹配和限定用的

正则元字符
匹配：
^
$
\w
\d
[A-Z]

限定
+ 1到多次
? 0到1次
* 0到多次

2.两种自动代理
DefaultAdvisorAutoProxyCreator
 默认顾问自动代理社生成器 ，正如他的名字，他只能对顾问做代理

 BeanNameAutoProxyCreator

 金牌结论：
 1.测试类中，由于没有代理工厂Bean，所以我们这次将getBean指向了目标对象，他其实上生成的是目标类的子类
 2.他们可以对多个目标类型中的特定方法做增强


3.AspectJ 实现AOP


2019年4月16日
1.初始AOP
 <!--4.绑定 AOP-->  ★★★★
   <aop:config>
      <!--切点   切点表达式::::设定拦截条件：：：：：：：：：-->
      <aop:pointcut id="mypoint" expression="execution(* *..service.impl.UserServiceImpl.save*(..))||execution(* *..service.impl.UserServiceImpl.update*(..))||execution(* *..service.impl.UserServiceImpl.del*(..))"></aop:pointcut>
      <!--织入-->
      <aop:advisor advice-ref="beforeAdvice" pointcut-ref="mypoint"></aop:advisor>
   </aop:config>


2.代理工厂Bean
<bean id="proxyService" class="org.springframework.aop.framework.ProxyFactoryBean">
    <!--目标对象-->
      <property name="targetName" value="someService"></property>
    <property name="interceptorNames" value="beforeAdvice"></property>
  </bean>


3.顾问的方式

  <!--3.使用顾问去包装通知   ::::名称匹配方法切入点顾问-->
  <bean id="myAdvisor" class="org.springframework.aop.support.NameMatchMethodPointcutAdvisor">
    <property name="advice" ref="beforeAdvice"></property>
    <property name="mappedNames" value="add"></property>
  </bean>


  <bean id="proxyService" class="org.springframework.aop.framework.ProxyFactoryBean">
    <!--目标对象-->
      <property name="targetName" value="someService"></property>
    <property name="interceptorNames" value="myAdvisor"></property>
  </bean>


4.自动代理



  <!--3.使用顾问去包装通知   ::::正则方法切入点顾问-->
  <bean id="myAdvisor" class="org.springframework.aop.support.RegexpMethodPointcutAdvisor">
    <property name="advice" ref="beforeAdvice"></property>
    <property name="patterns" value=".*add.*"></property>
  </bean>
  <!--自动代理  默认Advisor自动代理生成器  弊端：：只能代理顾问-->
   <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"></bean>
5.AspectJ  注解  ★★★★
@Aspect
public class MyAspect {
   /* //前置增强
    @Before(value ="execution(* *..*.day20aspectjanno.SomeService.*(..))")
    public void myBefore(){
        System.out.println("这是前置增强");
    }
    <!--目标类-->
    <bean id="someService" class="cn.spring.day20aspectjanno.SomeService"></bean>
    <!--切面类-->
    <bean id="myAspect" class="cn.spring.day20aspectjanno.MyAspect"></bean>

    <!--寻址注解-->
    <aop:aspectj-autoproxy></aop:aspectj-autoproxy>


6.Schema 约束  xml配置    ★★★★★

public class MyAspect {
    //随手写一个方法
    //前置方法
    public void myBefore(){
        System.out.println("前置增强");
    }

    //后置方法
    public void myAfterReturning(){
        System.out.println("后置增强");
    }

}
<!--AOP config的配置-->
  <aop:config>
    <!--切点表达式-->
     <aop:pointcut id="mypoint" expression="execution(* *..*.day21aspectjxml.*.*(..))"></aop:pointcut>
    <!--切面-->
    <aop:aspect ref="myAspect">
     <!--前置增强-->
       <aop:before method="myBefore" pointcut-ref="mypoint"></aop:before>
      <!--后置增强-->
      <aop:after-returning method="myAfterReturning" pointcut-ref="mypoint"></aop:after-returning>
     </aop:aspect>
  </aop:config>
</beans>



JDBC：Java DataBase Connectivity  Java数据库连接
Java -------------> DB
Template:模板
模板引擎
大家千万注意意见事情，你不要以为，咱们java开发，页面承载数据
html和jsp  freeMarker 研究一下  theamleaf volocity

Mybatis
JDBC：
DbUtils:
select * from UserInfo-------------------->List<UserInfo>
JDBCTemplate:

public interface RowMapper<T> {
    T mapRow(ResultSet var1, int var2) throws SQLException;
}

是一个接口

ResultSet不保存数据，     读取器
成果：复旦 哲学  老师

金钱是工具  通向幸福，自信

运河：工具

优化了：
1.jdbc.properties
2.xml中配置不再用JDBCTemplate做中间桥梁  DAO和DataSource直接交互。
3.RowMapper接口

2019年4月18日
1.jdbcTemplate  基于jDBC 高于 JDBC
四大对象
Connection
PrepareStatement
ResultSet
---------------------
DriverManager
Class.forName

JDBC操作DB，使用的API称为低级API  底层 ，可以对干预性更强。

jdbcTemplate高级API。暴露了一个高级的编程接口，对程序员公开的接口不是特别透明 ，告诉我们
入参和结果。至于底层数据库和连接直接关系，我们需要看底层的code才能知道原理。
query(sql,RowMapper)

短信接口
支付接口 json
邮箱接口
第三方接口
微信支付  xml数据

按照规范传递特定格式的数据，阿里云支付宝，沙箱环境测试支付。
商户的编号，订单号，订单金额，令牌，加密----------> 返回给一个支付成功或者是失败的json值。

JDBCTemplate




public class BookDAOImpl extends JdbcDaoSupport implements  IBookDAO{
   public void findAllBooks(){
      String sql="select * from book";
      //谁帮我执行sql
      //JDBC  PS  迫切的需要一个命令对象执行sql，找到了JDBCTempldate类
      this.getJdbcTemplate().query(sql);
   }
}

识别到文件
<context:property-placeholder location=>
数据源
  四种
  Spring内置的
    DriverManagerDtaSource
  dbcp连接池
  c3p0  ComboPooledDataSource
  阿里druid
  DruidDataSource


JDBCTemplate
DAO------》JDBCTemplate
DAO------》DataSource

service-------》DAO


容器取出service
可以了


public class JdbcDaoSupport{
   private JdbcTemplate:
   private Datasource datasource;
}

//手写框架

//手写Tomcat


//xml +反射 ++++动态代理 ++++设置模式














